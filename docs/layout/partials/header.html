<section class="banner-text-container">
  <h1 class="banner-heading" id="whats-taiko"> Reliable browser automation </h1>
  <p class="banner-text-container_desc">
      <a href="https://github.com/getgauge/taiko">Taiko</a> is a free and open source browser automation tool built by the team behind <a href="https://gauge.org">Gauge by ThoughtWorks</a>. It is a node library with a clear and concise API to automate the chrome browser. Taiko uses the Chrome DevTools API and is built ground up to test modern web applications.
  </p>
</section>

<section class="quick-install">
  <h2 id="quick-install">Quick Install</h2>
  <p>Taiko works on Windows, MacOS and linux. 
  </p>
  <p class="note">
    Note: You need to have <a href="https://nodejs.org/">Node.js</a> installed in your system to start writing Taiko scripts in JavaScript. 
  </p>
  <p>Open a terminal application (or powershell in the case of windows) and install Taiko using <span class="highlight">npm</span>
  </p>
  <div class="code-section">
  <code>
    <pre> 
        <span class="white">npm install -g taiko</span>
    </pre>
  </code>
</div>
<p>This installs the taiko and the latest version of the chromium browser. Now, we are all set to do some testing!
</p>

<p class="note">
  You can use Taiko with a test runner of your choice. We highly recommend using <a href="#integrating-gauge">Taiko with Gauge</a>.
</p>

</section>

<section class="taiko-features">
  <h2 id="taiko-features">Taiko Features</h2>
  <p>
    We built Taiko to make browser automation reliable. To fix the underlying problem behind ‘flaky tests’ and improve the browser automation experience, Taiko comes with an <a href="#interactive-recorder">interactive recorder</a> and a powerful API that provides 
    <ul class="desc-list">
      <li><a href="#smart-selectors">Smart Selectors</a></li>
      <li><a href="#xhr-dynamic-content">Ability to handle XHR and dynamic content</a></li>
      <li><a href="#request-response">Request/Response stubbing and mocking</a></li>
    </ul>
  </p>
</section>


<section class="get-started">
  <h2 id="get-started">Getting Started with Taiko</h2>

  <div class="sub-section">
    <h3 id="interactive-recorder">Interactive Recorder</h3>
    <p>
      Taiko comes with a Recorder that’s a <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a> to write test scripts. You can use Taiko’s API to control the browser from REPL. 
    </p>
    <p>
      To launch the REPL type <span class="highlight">taiko</span> in your favorite terminal application.
    </p>
    <div class="code-section">
      <code>
        <pre>
          <span class="white">
            taiko 
          </span>
        </pre>
      </code>
    </div>
    <p>This launches the Taiko prompt.</p>
      <div class="code-section">
        <code>
          <pre>
            <span class="white">
              Version: 0.2.0 (Chromium:69.0.3476.0) <br />
              Type .api for help and .exit to quit <br />
              > <br />
            </span>
          </pre>
        </code>
      </div>
      <p>You can now use Taiko’s API as commands in this prompt. For example, to launch a Chrome browser instance use
    </p>
    <div class="code-section">
      <code>
        <pre>
            <span class="white">openBrowser() </span>
        </pre>
      </code>
    </div>
    <p>
      To automate this Chrome browser instance, you can use other commands from the Taiko API. Here's another example to get the browser to search google for something. 
    </p>
    <div class="code-section">
      <code>
        <pre>
            <span class="white">
            goto(“google.com”) <br />
            write(“taiko test automation”) <br />
            click(“Google Search”) <br />
            </span>
        </pre>
      </code>
    </div>
    <p>These commands get the browser to 
      <ul class="desc-list">
        <li>go to google’s home page, </li>
        <li>type the text “taiko test automation” and then </li>
        <li>click on the “Google Search” button.</li>
      </ul>
    </p>
    <p>You can see the browser performing these actions as you type and press enter for each command.
    </p>
    <img src="{{asset 'images/usage.gif'}}" class="img-responsive" />
    <p>Taiko’s REPL keeps a history of all successful commands. Once you finish a flow of execution, you can generate a test script using the special command <span class="highlight">.code</span>
    </p>

    <div class="code-section">
      <code>
        <pre>
          <span class="white">
          .code
          </span>
        </pre>
      </code>
    </div>
    <p>On execution, taiko generates readable and maintainable JavaScript code.</p>
    <div class="code-section">
      <code>
        <pre>
          <span class="white">
          const { openBrowser, goto, write, click } = require('taiko');<br />

          (async () => {<br />
            try {<br />
                await openBrowser();<br />
                await goto("google.com");<br />
                await write("taiko test automation");<br />
                await click("Google Search");<br />
            } catch (e) {<br />
                  console.error(e);<br />
            } finally {<br />
                  closeBrowser();<br />
            }<br />
          })();<br />
          </span>
        </pre>
      </code>
    </div>

    <p>You can copy and modify this code or save it directly to a file using          
    </p>
    <div class="code-section">
      <code>
        <pre>
          <span class="white">
          .code googlesearch.js
          </span>
        </pre>
      </code>
    </div>

    <p>Choose to continue automating or finish the recording using 
    </p>
    <div class="code-section">
      <code>
        <pre>
          <span class="white">
          .exit
          </span>
        </pre>
      </code>
    </div>
    <p>To run a Taiko script pass the file as an argument to <span class="highlight">taiko</span>
    </p>
    <div class="code-section">
      <code>
        <pre>
          <span class="white">taiko googlesearch.js</span>
        </pre>
      </code>
    </div>
    <p>By default Taiko runs the script in headless mode - that means it does not launch a browser window. This makes it easy to run Taiko in containers like Docker. 
    </p>
    <div class="code-section code-section_output">
      <code>
        <pre>
          <span class="white">
          ✔ Browser opened<br />
          ✔ Navigated to url "http://google.com" <br />
          ✔ Wrote taiko test automation into the focused element.<br />
          ✔ Clicked element containing text "Google Search"<br />
          ✔ Browser closed<br />
          </span>
        </pre>
      </code>
    </div>
    <p>To view the browser when the script executes use 
    </p>
    <div class="code-section">
      <code>
        <pre>
          <span class="white">
            taiko googlesearch.js --observe
          </span>
        </pre>
      </code>
    </div>

    <p>
      Taiko’s REPL also documents all the API’s. To view the documentation use this command.
    </p>
    <div class="code-section">
      <code>
        <pre>
          <span class="white">.api
          </span>
        </pre>
      </code>
    </div>
    <p>To see more details of an API along with examples use <span class="highlight">.api</span> with the name of the api. Here's an example
    </p>
    <div class="code-section">
      <code>
        <pre>
          <span class="white">
          .api openBrowser
          </span>
        </pre>
      </code>
    </div>
    <p>This will generate details of the API along with examples.</p>
  <div class="code-section">
    <code>
      <pre>
        <span class="white">
          Launches a browser with a tab. The browser will be closed when the parent node.js process is closed. <br />
          openBrowser() <br />
          openBrowser({ headless: false }) <br />
          openBrowser({args:['--window-size=1440,900']}) <br />
        </span>
      </pre>
    </code>
  </div>  
        
      
      </div>

  <div class="sub-section">
    <h3 id="smart-selectors">Smart Selectors</h3>
    <p>
        Taiko’s API treats the browser as a black box. With Taiko you can write scripts by looking at a web page and without inspecting it’s source code. </p>
        <p>For example on google.com, this command will click on any element with the text 'Google Search' (a button on the page).
    </p>
    <div class="code-section">
    <code>
      <pre>
        <span class="white">
        click(“Google Search”)
        </span>
      </pre>
    </code>
  </div>
    <p>
      Taiko’s API mimics user interactions with the browser. For example if you want to write into an element that’s currently in focus, use 
    </p>
    <div class="code-section">
      <code>
        <pre>
          <span class="white">
          write(“something”)
          </span>
        </pre>
      </code>
    </div>
    <p>
      Or if you want to write into a specific text field 
    </p>
    <div class="code-section">
    <code>
        <pre>
          <span class="white">write(“something”, into(textField({placeholder: “Username”})))
          </span>
        </pre>
    </code>
  </div>
    <p>
        With Taiko’s API you can avoid using ids/css/xpath selectors to create reliable tests that don’t break with changes in the web page’s structure.
    </p>
    <p>You can also use Taiko’s proximity selectors to visually locate elements. For example, this command will click the checkbox that is nearest to any element with the text 'Username'.</p>
    <div class="code-section">
    <code>
        <pre>click(checkbox(near(“Username”)))
        </pre>
    </code>
  </div>
    <p>
      Taiko’s also supports XPath and CSS selectors.
    </p>
    <div class="code-section">
      <code>
        <pre>
          <span class="white">
          click($(“#button_id”)) // Using CSS selectors
          </span>
        </pre>
      </code>
    </div>
    <div class="code-section">
      <code>
        <pre>
          <span class="white">
          click($(“//input[name=`button_name`]”)) // Xpath selectors
          </span>
        </pre>
      </code>
    </div>
  </div>
  <div class="sub-section">
    <h3 id="xhr-dynamic-content">Ability to handle XHR and dynamic content</h3>
    <p>
      Taiko’s API listens to actions that trigger XHR request or fetch dynamic content and automatically waits for them to complete before moving on to the next action. Taiko implicitly waits for elements to load on the page before performing executing the command. Scripts written in Taiko are free of explicit local or global waits to reduce ‘flakiness’. 
    </p>
  </div>

  <div class="sub-section">
    <h3 id="request-response">Request/Response stubbing and mocking</h3>
    <p>
      Setting up test infrastructure and test data is hard. Taiko makes this easy with the <span class="highlight">intercept</span> API. For example, 
    </p>
    <p>
      blocking requests on a page  (like Google Analytics or any other resource)
    </p>

    <div class="code-section">
      <code>
        <pre>
          <span class="white">
          intercept("https://www.google-analytics.com/analytics.js");
          </span>
        </pre>
      </code>
    </div>
    <p>or redirecting an XHR request on the page to a test instance
    </p>
    <div class="code-section">
      <code>
        <pre>
          <span class="white">
          intercept(“https://fetchdata.com”, “http://fetchtestdata.com”)
          </span>
        </pre>
      </code>
    </div>
    <p>
    stubbing an XHR request to return custom data
    </p>
    <div class="code-section">
      <code>
        <pre>
          <span class="white">
          intercept(“https://fetchdata.com”, {“test”: data})
          </span>
        </pre>
      </code>
    </div>
    <p>
     modify data sent by the XHR request
    </p>
    <div class="code-section">
      <code>
        <pre> 
          <span class="white">
          intercept(“https://fetchdata.com”, (request) =>  <br />
            {request.continue({“custom”: “data”})})) <br />
          </span>
        </pre>
      </code>
    </div>
    <p>This simplifies test setups as Taiko doesn’t have to set up mock servers, or replace URLs in tests to point to test instances.
    </p>
  </div>
</section>

<section class="gauage-integration">
  <h2 id="integrating-gauge">Integrating with Gauge</h3>
  <p>
    We recommend using Taiko with Gauge. Gauge is a test runner for writing readable and reusable acceptance tests. It is easy to install and well integrated with Taiko. 
  </p>
  <p>
    Install Gauge using <span class="highlight">npm</span>
  </p>
  <div class="code-section">
    <code>
      <pre>
        <span class="white">
          npm install @getgauge/cli
        </span>
      </pre>
    </code>
  </div>
  <p> and initialize a sample Taiko project using</p>
  <div class="code-section">
      <code>
        <pre>
          <span class="white">
            gauge init js
          </span>
        </pre>
      </code>
    </div>
  <p>Learn more about using Gauge and Taiko together from this <a href="https://github.com/getgauge-examples/js-taiko" target="_blank">sample project</a>.</p>
</section>
